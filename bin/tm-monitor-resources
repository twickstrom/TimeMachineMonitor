#!/usr/bin/env bash
# tm-monitor-resources - Monitor resource usage of tm-monitor processes
# Optimized version using centralized core.sh and library functions

set -uo pipefail

# Initialize using core.sh with full library set
source "$(dirname "${BASH_SOURCE[0]}")/../lib/core.sh"
tm_monitor_init "${BASH_SOURCE[0]}" "full"

# Source argument parsing
source "$TM_LIB_DIR/arguments.sh"

# Column width constants - Total width must equal 76
readonly COL_PID=6       # PID column
readonly COL_CPU=8       # CPU% column  
readonly COL_MEM=8       # MEM% column
readonly COL_RSS=8       # RSS(MB) column
readonly COL_TIME=10     # TIME column
readonly COL_CMD=29      # COMMAND column

# Minimum terminal size
readonly MIN_COLS=76
readonly MIN_ROWS=42  # Prevents header duplication with 5+ processes

# Fixed width divider constant (for backward compatibility)
readonly DIVIDER="----------------------------------------------------------------------------"

# Content row counts for display calculation
readonly HEADER_ROWS=2           # Title + divider
readonly PROCESS_TABLE_ROWS=10   # Header(2) + up to 5 processes + divider + total + buffer
readonly IMPACT_ROWS=4           # Section header + 3 lines
readonly LOAD_ROWS=4             # Section header + 2 lines
readonly TM_STATUS_ROWS=8        # Section header + up to 6 lines
readonly SESSION_STATS_ROWS=7    # Section header + 5 lines + divider
readonly FOOTER_ROWS=1           # Footer message only (no blank line)
readonly TOTAL_CONTENT_ROWS=42   # Total rows needed for full display

# Show usage
usage() {
    cat <<EOF
Usage: $(basename "$0") [options]

Monitor CPU/memory usage of tm-monitor processes and Time Machine status.

Options:
  -w, --watch          Continuous monitoring (updates every 2 seconds)
  -i, --interval <sec> Update interval for watch mode (default: 2)
  -c, --no-colors      Disable colored output
  -h, --help           Show this help message
  -v, --version        Show version

Examples:
  $(basename "$0")              # Show current status once
  $(basename "$0") --watch      # Continuous monitoring
  $(basename "$0") -w -i 5      # Update every 5 seconds

Displayed Information:
  • Process Resources
    - PID, CPU%, MEM%, RSS (MB), TIME, COMMAND
    - Total resource usage and system impact assessment
  
  • Time Machine Status
    - Current backup status (Running/Idle/Not Running)
    - Backup phase and progress percentage
    - Data copied vs total data size
  
  • Session Statistics
    - Monitoring session duration
    - Number of samples collected
    - Average backup speed (calculated from TM data)
    - Failure count

Note on Metrics:
  - CPU%: Percentage of CPU used by the process
  - MEM%: Percentage of total system memory used
  - RSS: Resident Set Size - actual physical memory used (in MB)

EOF
    exit 0
}

# Display resource information - optimized for minimal repainting
display_resources() {
    # Get current terminal size
    local term_rows term_cols
    local size
    size=$(get_terminal_size)
    term_rows="${size%% *}"
    term_cols="${size#* }"
    
    # Check if terminal is large enough for all content
    if [[ "$term_rows" -lt "$TOTAL_CONTENT_ROWS" ]] || [[ "$term_cols" -lt "$MIN_COLS" ]]; then
        # Show warning at current position
        cursor_home
        clear_from_cursor
        printf "${COLOR_BOLD_YELLOW}⚠ Terminal too small!${COLOR_RESET}\n"
        printf "Current size: ${term_cols}x${term_rows}\n"
        printf "Required size: ${MIN_COLS}x${TOTAL_CONTENT_ROWS}\n"
        printf "\nPlease resize your terminal window.\n"
        return 1
    fi
    
    # Move to home position - we'll update line by line
    cursor_home
    
    # Title - exactly 76 chars wide (with line clear to handle any residual text)
    local timestamp
    timestamp=$(format_timestamp "" "%Y-%m-%d %H:%M:%S")
    local title="TM-Monitor Resource Usage - ${timestamp}"
    # Truncate title if too long
    if [[ ${#title} -gt 76 ]]; then
        title="${title:0:73}..."
    fi
    printf "\r${COLOR_BOLD_BLUE}%-76s${COLOR_RESET}\033[K\n" "$title"
    printf "\r%-.76s\033[K\n" "${DIVIDER}"
    
    # Find processes using centralized functions
    local monitor_procs helper_procs backupd_procs backupd_helper_procs
    monitor_procs=$(find_tm_monitor_processes)
    helper_procs=$(find_tm_monitor_helper_processes)
    backupd_procs=$(find_backupd_processes)
    backupd_helper_procs=$(find_backupd_helper_processes)
    
    # Process table header - exactly 76 chars with line clearing
    printf "\r%-76.76s\033[K\n" "$(printf "%-6s%8s %8s %8s    %-10s %-29s" "PID" "CPU%" "MEM%" "RSS(MB)" "TIME" "COMMAND")"
    printf "\r%-.76s\033[K\n" "${DIVIDER}"
    
    # Display processes using centralized function
    # Track lines used to ensure consistent spacing
    local process_lines=0
    
    # Count actual lines that will be displayed
    [[ -n "$monitor_procs" ]] && process_lines=$((process_lines + $(echo "$monitor_procs" | wc -l)))
    [[ -z "$monitor_procs" ]] && ((process_lines++))
    
    [[ -n "$helper_procs" ]] && process_lines=$((process_lines + $(echo "$helper_procs" | wc -l)))
    [[ -z "$helper_procs" ]] && ((process_lines++))
    
    [[ -n "$backupd_procs" ]] && process_lines=$((process_lines + $(echo "$backupd_procs" | wc -l)))
    [[ -z "$backupd_procs" ]] && ((process_lines++))
    
    [[ -n "$backupd_helper_procs" ]] && process_lines=$((process_lines + $(echo "$backupd_helper_procs" | wc -l)))
    [[ -z "$backupd_helper_procs" ]] && ((process_lines++))
    
    # Display the processes
    display_processes_or_placeholder "$monitor_procs" "tm-monitor" "false" "$USE_COLORS"
    display_processes_or_placeholder "$helper_procs" "tm-monitor-helper" "true" "$USE_COLORS"
    display_processes_or_placeholder "$backupd_procs" "Time Machine (backupd)" "true" "$USE_COLORS"
    display_processes_or_placeholder "$backupd_helper_procs" "Time Machine (backupd-helper)" "true" "$USE_COLORS"
    
    # Pad to ensure we always use 5 lines for processes (allowing for one extra spawned process)
    while [[ $process_lines -lt 5 ]]; do
        printf "\r%76s\033[K\n" " "
        ((process_lines++))
    done
    
    # Calculate totals using centralized function
    local all_procs total_cpu=0 total_mem=0 total_rss=0 process_count=0
    all_procs=$({
        [[ -n "$monitor_procs" ]] && echo "$monitor_procs"
        [[ -n "$helper_procs" ]] && echo "$helper_procs"
        [[ -n "$backupd_procs" ]] && echo "$backupd_procs"
        [[ -n "$backupd_helper_procs" ]] && echo "$backupd_helper_procs"
    })
    
    if [[ -n "$all_procs" ]]; then
        local totals
        totals=$(get_process_totals "$all_procs")
        IFS='|' read -r total_cpu total_mem total_rss process_count <<< "$totals"
    fi
    
    printf "\r%-.76s\033[K\n" "${DIVIDER}"
    
    # Format totals using centralized formatting
    total_cpu=$(format_decimal "$total_cpu" 2 "0.00")
    total_mem=$(format_decimal "$total_mem" 2 "0.00")
    total_rss=$(format_decimal "$total_rss" 2 "0.00")
    
    printf "\r%-76.76s\033[K\n" "$(printf "%-6s%8s %8s %8s" "TOTAL" "${total_cpu}" "${total_mem}" "${total_rss}")"
    
    # Impact Assessment using centralized functions
    display_impact_assessment "$total_cpu" "$total_mem" "$total_rss"
    
    # System Load using centralized functions
    display_system_load
    
    # Time Machine Status using centralized tmutil functions
    display_tm_status
    
    # Session Statistics using state.sh functions
    display_session_stats
}

# Display impact assessment section
display_impact_assessment() {
    local total_cpu="$1"
    local total_mem="$2"
    local total_rss="$3"
    
    local num_cores total_mem_gb
    num_cores=$(get_cpu_cores)
    total_mem_gb=$(get_total_memory_gb)
    
    # Section header with line-by-line updates
    printf "\n\r${COLOR_BOLD_CYAN}%-76.76s${COLOR_RESET}\033[K\n" "Impact Assessment"
    printf "\r%-.76s\033[K\n" "${DIVIDER}"
    
    # CPU impact
    local cpu_impact cpu_level cpu_color
    cpu_impact=$(get_impact_level "$total_cpu" "2" "5")
    IFS='|' read -r cpu_level cpu_color <<< "$cpu_impact"
    printf "\r%-20s: ${cpu_color}%-8s${COLOR_RESET} %s%% of %d cores\033[K\n" "CPU Usage" "$cpu_level" "$(format_percentage "$total_cpu" false "0.00")" "$num_cores"
    
    # Memory percentage impact
    local mem_pct_impact mem_pct_level mem_pct_color
    mem_pct_impact=$(get_impact_level "$total_mem" "1.0" "5.0")
    IFS='|' read -r mem_pct_level mem_pct_color <<< "$mem_pct_impact"
    printf "\r%-20s: ${mem_pct_color}%-8s${COLOR_RESET} %s%% of system RAM\033[K\n" "Memory Percentage" "$mem_pct_level" "$(format_percentage "$total_mem" false "0.00")"
    
    # Memory RSS impact - dynamic thresholds
    local total_mem_mb rss_low_threshold rss_high_threshold
    total_mem_mb=$(echo "$total_mem_gb * 1024" | bc -l 2>/dev/null | cut -d. -f1)
    rss_low_threshold=$(echo "$total_mem_mb * 0.01" | bc -l 2>/dev/null | cut -d. -f1)
    rss_high_threshold=$(echo "$total_mem_mb * 0.05" | bc -l 2>/dev/null | cut -d. -f1)
    
    [[ -z "$rss_low_threshold" || "$rss_low_threshold" -lt 500 ]] && rss_low_threshold=500
    [[ -z "$rss_high_threshold" || "$rss_high_threshold" -lt 2000 ]] && rss_high_threshold=2000
    
    local mem_rss_impact mem_rss_level mem_rss_color
    mem_rss_impact=$(get_impact_level "$total_rss" "$rss_low_threshold" "$rss_high_threshold")
    IFS='|' read -r mem_rss_level mem_rss_color <<< "$mem_rss_impact"
    
    local rss_pct
    rss_pct=$(echo "scale=3; $total_rss / $total_mem_mb * 100" | bc -l 2>/dev/null)
    rss_pct=$(format_percentage "$rss_pct" false "0.00")
    
    printf "\r%-20s: ${mem_rss_color}%-8s${COLOR_RESET} %s MB (%s%% of %.1f GB)\033[K\n" "Memory Size (RSS)" "$mem_rss_level" "$total_rss" "$rss_pct" "$total_mem_gb"
}

# Display system load section
display_system_load() {
    local num_cores
    num_cores=$(get_cpu_cores)
    
    # Section header with line-by-line updates
    printf "\n\r${COLOR_BOLD_CYAN}%-76.76s${COLOR_RESET}\033[K\n" "System Load"
    printf "\r%-.76s\033[K\n" "${DIVIDER}"
    
    # Get load averages using centralized function
    local load1 load5 load15
    IFS='|' read -r load1 load5 load15 <<< "$(get_load_averages)"
    
    # Get colors using centralized function
    local load1_color load5_color load15_color
    load1_color=$(get_load_color "$load1" "$num_cores")
    load5_color=$(get_load_color "$load5" "$num_cores")
    load15_color=$(get_load_color "$load15" "$num_cores")
    
    # Format using centralized functions
    local formatted_load1 formatted_load5 formatted_load15
    formatted_load1=$(format_decimal "$load1" 2 "0.00")
    formatted_load5=$(format_decimal "$load5" 2 "0.00")
    formatted_load15=$(format_decimal "$load15" 2 "0.00")
    
    printf "\r%-20s: ${load1_color}%s${COLOR_RESET} 1m   ${load5_color}%s${COLOR_RESET} 5m   ${load15_color}%s${COLOR_RESET} 15m\033[K\n" "Load Averages" "$formatted_load1" "$formatted_load5" "$formatted_load15"
    
    # Status using centralized function
    local load_status load_color
    load_status=$(get_load_status)
    case "$load_status" in
        Normal) load_color="$COLOR_GREEN" ;;
        Elevated) load_color="$COLOR_BOLD_YELLOW" ;;
        High) load_color="$COLOR_RED" ;;
        *) load_color="$COLOR_RESET" ;;
    esac
    
    printf "\r%-20s: ${load_color}%s${COLOR_RESET} (%s / %d cores)\033[K\n" "Status" "$load_status" "$(format_decimal "$load1" 2 "0.00")" "$num_cores"
}

# Display Time Machine status - now using centralized tmutil functions
display_tm_status() {
    # Section header with line-by-line updates
    printf "\n\r${COLOR_BOLD_CYAN}%-76.76s${COLOR_RESET}\033[K\n" "Time Machine Status"
    printf "\r%-.76s\033[K\n" "${DIVIDER}"
    
    # Use centralized tmutil function directly
    local tm_status status phase percent size_gb total_gb
    tm_status=$(get_tmutil_simple_status 2>/dev/null)
    
    if [[ -z "$tm_status" ]]; then
        ((SESSION_FAILURE_COUNT++))
        tm_status="Not Running|-|-|-|-"
    fi
    
    IFS='|' read -r status phase percent size_gb total_gb <<< "$tm_status"
    
    # Update state for speed tracking
    parse_tmutil_status >/dev/null 2>&1
    if [[ -n "${TM_BYTES:-}" ]] && [[ "$TM_BYTES" -gt 0 ]]; then
        update_state "$(get_tmutil_json 2>/dev/null)" 2>/dev/null || true
    fi
    
    printf "\r%-20s: " "Status"
    
    # Color the status
    local status_color
    case "$status" in
        Running) status_color="$COLOR_GREEN" ;;
        Stopping) status_color="$COLOR_RED" ;;
        "Not Running") status_color="$COLOR_BOLD_YELLOW" ;;
        *) status_color="$COLOR_CYAN" ;;
    esac
    printf "${status_color}%s${COLOR_RESET}\033[K\n" "$status"
    
    if [[ "$status" == "Running" ]] || [[ "$status" == "Stopping" ]]; then
        printf "\r%-20s: %s\033[K\n" "Phase" "$phase"
        printf "\r%-20s: %s\033[K\n" "Progress" "$(format_percentage "$percent" true "0.00")"
        printf "\r%-20s: %s GB (current batch)\033[K\n" "Data Copied" "$(format_decimal "$size_gb" 2 "0.00")"
        printf "\r%-20s: %s GB (sparsebundle)\033[K\n" "Estimated Size" "$(format_decimal "$total_gb" 2 "0.00")"
        
        # Add ETA if available
        if [[ "${TM_TIME_REMAINING:-0}" -gt 0 ]]; then
            printf "\r%-20s: %s\033[K\n" "ETA" "$(format_eta "$TM_TIME_REMAINING")"
        fi
        
        # Show changed items if in preparation
        if [[ "${TM_PHASE:-}" == "Starting" ]] && [[ "${TM_NUMBER_OF_CHANGED_ITEMS:-0}" -gt 0 ]]; then
            printf "\r%-20s: %s\033[K\n" "Items Found" "$TM_NUMBER_OF_CHANGED_ITEMS"
        fi
    else
        # Placeholder fields
        for field in "Phase" "Progress" "Data Copied" "Estimated Size"; do
            printf "\r%-20s: -\033[K\n" "$field"
        done
    fi
}

# Display session statistics using state.sh functions
display_session_stats() {
    # Section header with line-by-line updates
    printf "\n\r${COLOR_BOLD_CYAN}%-76.76s${COLOR_RESET}\033[K\n" "Session Statistics"
    printf "\r%-.76s\033[K\n" "${DIVIDER}"
    
    # Update sample count
    ((SESSION_SAMPLE_COUNT++))
    
    # Get values using state.sh functions
    local avg_speed_bytes avg_speed_mb session_duration
    avg_speed_bytes=$(get_average_speed)
    avg_speed_mb=$(format_speed_mbps "$avg_speed_bytes")
    session_duration=$(get_session_duration)
    
    printf "\r%-20s: %s\033[K\n" "Duration" "$(format_duration "$session_duration" "AUTO")"
    printf "\r%-20s: %s\033[K\n" "Samples" "$(format_integer "$SESSION_SAMPLE_COUNT" false "0")"
    printf "\r%-20s: %s\033[K\n" "Average Speed" "$avg_speed_mb"
    printf "\r%-20s: %s\033[K\n" "Speed Samples" "$(format_integer "${#SPEED_SAMPLES[@]}" false "0")"
    printf "\r%-20s: %s\033[K\n" "Failures" "$(format_integer "$SESSION_FAILURE_COUNT" false "0")"
}

# Handle interrupt signal gracefully
handle_interrupt() {
    reset_scroll_region
    cleanup_terminal_monitoring
    echo
    echo "Monitoring stopped."
    echo
    get_session_summary
    exit 0
}

# Main execution
main() {
    # Parse arguments using centralized function
    if ! parse_resources_args "$@"; then
        usage
    fi
    
    if [[ "$WATCH_MODE" == "true" ]]; then
        # Continuous monitoring
        setup_terminal_monitoring
        init_session
        
        # Set up signal handlers
        trap 'handle_interrupt' INT TERM
        trap 'cleanup_terminal_monitoring; reset_scroll_region' EXIT
        
        # Initial setup
        local first_draw=true
        local last_term_rows=0
        local last_term_cols=0
        
        # Main loop
        while true; do
            # Get current terminal size
            local term_rows term_cols
            local size
            size=$(get_terminal_size "true")  # Force refresh
            term_rows="${size%% *}"
            term_cols="${size#* }"
            
            # Detect terminal size change
            if [[ "$term_rows" != "$last_term_rows" ]] || [[ "$term_cols" != "$last_term_cols" ]]; then
                # Terminal size changed - need full redraw
                reset_scroll_region
                clear_screen
                first_draw=true
                last_term_rows="$term_rows"
                last_term_cols="$term_cols"
            fi
            
            # Check if terminal is large enough
            if [[ "$term_rows" -lt "$TOTAL_CONTENT_ROWS" ]] || [[ "$term_cols" -lt "$MIN_COLS" ]]; then
                # Terminal too small - show warning and footer
                cursor_home
                display_resources
                
                # Position footer at bottom of actual terminal
                if [[ "$term_rows" -ge 6 ]]; then
                    printf "\033[%d;1H" "$term_rows"  # Move to last line
                    clear_line
                    printf "${COLOR_DIM}Press Ctrl+C to exit (updating every ${INTERVAL}s)${COLOR_RESET}"
                fi
            else
                # Terminal is large enough
                if [[ "$first_draw" == "true" ]]; then
                    # First draw - set up display area
                    clear_screen
                    
                    # Set scroll region to exclude footer line
                    printf "\033[1;%dr" $((term_rows - 1))
                    
                    # Draw footer at the bottom (outside scroll region)
                    printf "\033[%d;1H" "$term_rows"  # Move to last line
                    clear_line
                    printf "${COLOR_DIM}Press Ctrl+C to exit (updating every ${INTERVAL}s)${COLOR_RESET}"
                    
                    # Draw initial content
                    cursor_home
                    display_resources
                    
                    first_draw=false
                else
                    # Subsequent updates - just move cursor and update
                    cursor_home
                    display_resources
                fi
            fi
            
            sleep "$INTERVAL"
        done
    else
        # Single run mode
        init_session
        display_resources
    fi
}

# Run main
main "$@"
