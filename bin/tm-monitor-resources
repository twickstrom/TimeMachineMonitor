#!/usr/bin/env bash
# tm-monitor-resources - Monitor resource usage of tm-monitor processes
# Optimized version using centralized core.sh and library functions

set -uo pipefail

# Initialize using core.sh with full library set
source "$(dirname "${BASH_SOURCE[0]}")/../lib/core.sh"
tm_monitor_init "${BASH_SOURCE[0]}" "full"

# Source argument parsing
source "$TM_LIB_DIR/arguments.sh"

# Column width constants - Total width must equal 76
readonly COL_PID=6       # PID column
readonly COL_CPU=8       # CPU% column  
readonly COL_MEM=8       # MEM% column
readonly COL_RSS=8       # RSS(MB) column
readonly COL_TIME=10     # TIME column
readonly COL_CMD=29      # COMMAND column

# Minimum terminal size
readonly MIN_COLS=76
readonly MIN_ROWS=40

# Cache for system info (these don't change during execution)
CACHED_CPU_CORES=""
CACHED_TOTAL_MEM_GB=""

# Get cached CPU cores
get_cpu_cores_cached() {
    [[ -z "$CACHED_CPU_CORES" ]] && CACHED_CPU_CORES=$(get_cpu_cores)
    echo "$CACHED_CPU_CORES"
}

# Get cached total memory
get_total_memory_gb_cached() {
    [[ -z "$CACHED_TOTAL_MEM_GB" ]] && CACHED_TOTAL_MEM_GB=$(get_total_memory_gb)
    echo "$CACHED_TOTAL_MEM_GB"
}

# Show usage
usage() {
    cat <<EOF
Usage: $(basename "$0") [options]

Monitor CPU/memory usage of tm-monitor processes and Time Machine status.

Options:
  -w, --watch          Continuous monitoring (updates every 2 seconds)
  -i, --interval <sec> Update interval for watch mode (default: 2)
  -c, --no-colors      Disable colored output
  -h, --help           Show this help message
  -v, --version        Show version

Examples:
  $(basename "$0")              # Show current status once
  $(basename "$0") --watch      # Continuous monitoring
  $(basename "$0") -w -i 5      # Update every 5 seconds

Displayed Information:
  • Process Resources
    - PID, CPU%, MEM%, RSS (MB), TIME, COMMAND
    - Total resource usage and system impact assessment
  
  • Time Machine Status
    - Current backup status (Running/Idle/Not Running)
    - Backup phase and progress percentage
    - Data copied vs total data size
  
  • Session Statistics
    - Monitoring session duration
    - Number of samples collected
    - Average backup speed (calculated from TM data)
    - Failure count

Note on Metrics:
  - CPU%: Percentage of CPU used by the process
  - MEM%: Percentage of total system memory used
  - RSS: Resident Set Size - actual physical memory used (in MB)

EOF
    exit 0
}

# Display resource information - now using library functions
display_resources() {
    # Move to home position (we're in alternate buffer)
    cursor_home
    
    # Check terminal size using centralized function
    if ! check_terminal_minimum $MIN_ROWS $MIN_COLS; then
        print_terminal_warning $MIN_ROWS $MIN_COLS
        return 1
    fi
    
    # Header using centralized formatting
    local DIVIDER
    DIVIDER=$(draw_horizontal_line "-" 76)
    
    clear_line
    printf "${COLOR_BOLD_BLUE}%s${COLOR_RESET}\n" "TM-Monitor Resource Usage - $(format_timestamp "" "%Y-%m-%d %H:%M:%S")"
    clear_line
    echo "${DIVIDER}"
    
    # Find processes using centralized functions
    local monitor_procs helper_procs backupd_procs backupd_helper_procs
    monitor_procs=$(find_tm_monitor_processes)
    helper_procs=$(find_tm_monitor_helper_processes)
    backupd_procs=$(find_backupd_processes)
    backupd_helper_procs=$(find_backupd_helper_processes)
    
    # Process table header
    clear_line
    printf "%-6s%8s %8s %8s    %-10s %-29s\n" \
           "PID" "CPU%" "MEM%" "RSS(MB)" "TIME" "COMMAND"
    clear_line
    echo "${DIVIDER}"
    
    # Display processes using centralized function
    display_processes_or_placeholder "$monitor_procs" "tm-monitor" "false" "$USE_COLORS"
    display_processes_or_placeholder "$helper_procs" "tm-monitor-helper" "true" "$USE_COLORS"
    display_processes_or_placeholder "$backupd_procs" "Time Machine (backupd)" "true" "$USE_COLORS"
    display_processes_or_placeholder "$backupd_helper_procs" "Time Machine (backupd-helper)" "true" "$USE_COLORS"
    
    # Calculate totals using centralized function
    local all_procs total_cpu=0 total_mem=0 total_rss=0 process_count=0
    all_procs=$({
        [[ -n "$monitor_procs" ]] && echo "$monitor_procs"
        [[ -n "$helper_procs" ]] && echo "$helper_procs"
        [[ -n "$backupd_procs" ]] && echo "$backupd_procs"
        [[ -n "$backupd_helper_procs" ]] && echo "$backupd_helper_procs"
    })
    
    if [[ -n "$all_procs" ]]; then
        local totals
        totals=$(get_process_totals "$all_procs")
        IFS='|' read -r total_cpu total_mem total_rss process_count <<< "$totals"
    fi
    
    clear_line
    echo "${DIVIDER}"
    
    # Format totals using centralized formatting
    total_cpu=$(format_decimal "$total_cpu" 2 "0.00")
    total_mem=$(format_decimal "$total_mem" 2 "0.00")
    total_rss=$(format_decimal "$total_rss" 2 "0.00")
    
    clear_line
    printf "%-6s%8s %8s %8s\n" "TOTAL" "${total_cpu}" "${total_mem}" "${total_rss}"
    
    # Impact Assessment using centralized functions
    display_impact_assessment "$total_cpu" "$total_mem" "$total_rss"
    
    # System Load using centralized functions
    display_system_load
    
    # Time Machine Status using centralized tmutil functions
    display_tm_status
    
    # Session Statistics using state.sh functions
    display_session_stats
    
    # Footer
    clear_line
    printf "\n"
    clear_line
    printf "Press Ctrl+C to exit (updating every ${INTERVAL}s)\n"
}

# Display impact assessment section
display_impact_assessment() {
    local total_cpu="$1"
    local total_mem="$2"
    local total_rss="$3"
    
    local num_cores total_mem_gb
    num_cores=$(get_cpu_cores_cached)
    total_mem_gb=$(get_total_memory_gb_cached)
    
    print_section_header "Impact Assessment"
    
    # CPU impact
    local cpu_impact cpu_level cpu_color
    cpu_impact=$(get_impact_level "$total_cpu" "2" "5")
    IFS='|' read -r cpu_level cpu_color <<< "$cpu_impact"
    clear_line
    printf "%-20s: ${cpu_color}%-8s${COLOR_RESET} %s%% of %d cores\n" \
           "CPU Usage" "$cpu_level" "$(format_percentage "$total_cpu" false "0.00")" "$num_cores"
    
    # Memory percentage impact
    local mem_pct_impact mem_pct_level mem_pct_color
    mem_pct_impact=$(get_impact_level "$total_mem" "1.0" "5.0")
    IFS='|' read -r mem_pct_level mem_pct_color <<< "$mem_pct_impact"
    clear_line
    printf "%-20s: ${mem_pct_color}%-8s${COLOR_RESET} %s%% of system RAM\n" \
           "Memory Percentage" "$mem_pct_level" "$(format_percentage "$total_mem" false "0.00")"
    
    # Memory RSS impact - dynamic thresholds
    local total_mem_mb rss_low_threshold rss_high_threshold
    total_mem_mb=$(echo "$total_mem_gb * 1024" | bc -l 2>/dev/null | cut -d. -f1)
    rss_low_threshold=$(echo "$total_mem_mb * 0.01" | bc -l 2>/dev/null | cut -d. -f1)
    rss_high_threshold=$(echo "$total_mem_mb * 0.05" | bc -l 2>/dev/null | cut -d. -f1)
    
    [[ -z "$rss_low_threshold" || "$rss_low_threshold" -lt 500 ]] && rss_low_threshold=500
    [[ -z "$rss_high_threshold" || "$rss_high_threshold" -lt 2000 ]] && rss_high_threshold=2000
    
    local mem_rss_impact mem_rss_level mem_rss_color
    mem_rss_impact=$(get_impact_level "$total_rss" "$rss_low_threshold" "$rss_high_threshold")
    IFS='|' read -r mem_rss_level mem_rss_color <<< "$mem_rss_impact"
    
    local rss_pct
    rss_pct=$(echo "scale=3; $total_rss / $total_mem_mb * 100" | bc -l 2>/dev/null)
    rss_pct=$(format_percentage "$rss_pct" false "0.00")
    
    clear_line
    printf "%-20s: ${mem_rss_color}%-8s${COLOR_RESET} %s MB (%s%% of %.1f GB)\n" \
           "Memory Size (RSS)" "$mem_rss_level" "$total_rss" "$rss_pct" "$total_mem_gb"
}

# Display system load section
display_system_load() {
    local num_cores
    num_cores=$(get_cpu_cores_cached)
    
    print_section_header "System Load"
    
    # Get load averages using centralized function
    local load1 load5 load15
    IFS='|' read -r load1 load5 load15 <<< "$(get_load_averages)"
    
    # Get colors using centralized function
    local load1_color load5_color load15_color
    load1_color=$(get_load_color "$load1" "$num_cores")
    load5_color=$(get_load_color "$load5" "$num_cores")
    load15_color=$(get_load_color "$load15" "$num_cores")
    
    # Format using centralized functions
    local formatted_load1 formatted_load5 formatted_load15
    formatted_load1=$(format_decimal "$load1" 2 "0.00")
    formatted_load5=$(format_decimal "$load5" 2 "0.00")
    formatted_load15=$(format_decimal "$load15" 2 "0.00")
    
    clear_line
    printf "%-20s: ${load1_color}%s${COLOR_RESET} 1m   ${load5_color}%s${COLOR_RESET} 5m   ${load15_color}%s${COLOR_RESET} 15m\n" \
           "Load Averages" "$formatted_load1" "$formatted_load5" "$formatted_load15"
    
    # Status using centralized function
    local load_status load_color
    load_status=$(get_load_status)
    case "$load_status" in
        Normal) load_color="$COLOR_GREEN" ;;
        Elevated) load_color="$COLOR_BOLD_YELLOW" ;;
        High) load_color="$COLOR_RED" ;;
        *) load_color="$COLOR_RESET" ;;
    esac
    
    clear_line
    printf "%-20s: ${load_color}%s${COLOR_RESET} (%s / %d cores)\n" \
           "Status" "$load_status" "$(format_decimal "$load1" 2 "0.00")" "$num_cores"
}

# Display Time Machine status - now using centralized tmutil functions
display_tm_status() {
    print_section_header "Time Machine Status"
    
    # Use centralized tmutil function directly
    local tm_status status phase percent size_gb total_gb
    tm_status=$(get_tmutil_simple_status 2>/dev/null)
    
    if [[ -z "$tm_status" ]]; then
        ((SESSION_FAILURE_COUNT++))
        tm_status="Not Running|-|-|-|-"
    fi
    
    IFS='|' read -r status phase percent size_gb total_gb <<< "$tm_status"
    
    # Update state for speed tracking
    parse_tmutil_status >/dev/null 2>&1
    if [[ -n "${TM_BYTES:-}" ]] && [[ "$TM_BYTES" -gt 0 ]]; then
        update_state "$(get_tmutil_json 2>/dev/null)" 2>/dev/null || true
    fi
    
    clear_line
    printf "%-20s: " "Status"
    
    # Color the status
    local status_color
    case "$status" in
        Running) status_color="$COLOR_GREEN" ;;
        Stopping) status_color="$COLOR_RED" ;;
        "Not Running") status_color="$COLOR_BOLD_YELLOW" ;;
        *) status_color="$COLOR_CYAN" ;;
    esac
    printf "${status_color}%s${COLOR_RESET}\n" "$status"
    
    if [[ "$status" == "Running" ]] || [[ "$status" == "Stopping" ]]; then
        clear_line
        printf "%-20s: %s\n" "Phase" "$phase"
        clear_line
        printf "%-20s: %s\n" "Progress" "$(format_percentage "$percent" true "0.00")"
        clear_line
        printf "%-20s: %s GB (current batch)\n" "Data Copied" "$(format_decimal "$size_gb" 2 "0.00")"
        clear_line
        printf "%-20s: %s GB (sparsebundle)\n" "Estimated Size" "$(format_decimal "$total_gb" 2 "0.00")"
        
        # Add ETA if available
        if [[ "${TM_TIME_REMAINING:-0}" -gt 0 ]]; then
            clear_line
            printf "%-20s: %s\n" "ETA" "$(format_eta "$TM_TIME_REMAINING")"
        fi
        
        # Show changed items if in preparation
        if [[ "${TM_PHASE:-}" == "Starting" ]] && [[ "${TM_NUMBER_OF_CHANGED_ITEMS:-0}" -gt 0 ]]; then
            clear_line
            printf "%-20s: %s\n" "Items Found" "$TM_NUMBER_OF_CHANGED_ITEMS"
        fi
    else
        # Placeholder fields
        for field in "Phase" "Progress" "Data Copied" "Estimated Size"; do
            clear_line
            printf "%-20s: -\n" "$field"
        done
    fi
}

# Display session statistics using state.sh functions
display_session_stats() {
    print_section_header "Session Statistics"
    
    # Update sample count
    ((SESSION_SAMPLE_COUNT++))
    
    # Get values using state.sh functions
    local avg_speed_bytes avg_speed_mb session_duration
    avg_speed_bytes=$(get_average_speed)
    avg_speed_mb=$(format_speed_mbps "$avg_speed_bytes")
    session_duration=$(get_session_duration)
    
    clear_line
    printf "%-20s: %s\n" "Duration" "$(format_duration "$session_duration" "AUTO")"
    clear_line
    printf "%-20s: %s\n" "Samples" "$(format_integer "$SESSION_SAMPLE_COUNT" false "0")"
    clear_line
    printf "%-20s: %s\n" "Average Speed" "$avg_speed_mb"
    clear_line
    printf "%-20s: %s\n" "Speed Samples" "$(format_integer "${#SPEED_SAMPLES[@]}" false "0")"
    clear_line
    printf "%-20s: %s\n" "Failures" "$(format_integer "$SESSION_FAILURE_COUNT" false "0")"
}

# Handle interrupt signal gracefully
handle_interrupt() {
    cleanup_terminal_monitoring
    clear_line
    echo
    echo "Monitoring stopped."
    echo
    get_session_summary
    exit 0
}

# Main execution
main() {
    # Parse arguments using centralized function
    if ! parse_resources_args "$@"; then
        usage
    fi
    
    if [[ "$WATCH_MODE" == "true" ]]; then
        # Continuous monitoring
        setup_terminal_monitoring
        init_session
        
        # Set up signal handlers
        trap 'handle_interrupt' INT TERM
        trap 'cleanup_terminal_monitoring' EXIT
        
        # Main loop
        while true; do
            display_resources
            sleep "$INTERVAL"
        done
    else
        # Single run mode
        init_session
        display_resources
    fi
}

# Run main
main "$@"
