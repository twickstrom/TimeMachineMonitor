#!/usr/bin/env bash
# tm-monitor - Time Machine backup monitor main script
# Optimized version using centralized core.sh initialization

set -uo pipefail  # Removed -e to prevent early exit

# Initialize using core.sh - this replaces all the bootstrap and sourcing code
source "$(dirname "${BASH_SOURCE[0]}")/../lib/core.sh"
tm_monitor_init "${BASH_SOURCE[0]}" "standard"

# Source argument parsing
source "$TM_LIB_DIR/arguments.sh"

# Usage information
usage() {
    cat <<EOF
Usage: $(basename "$0") [options]

Monitor Time Machine backup progress with real-time updates.

Options:
  -i, --interval SECONDS   Update interval (default: $DEFAULT_INTERVAL)
  -u, --units 1000|1024    Size units: 1000 for GB, 1024 for GiB (default: $DEFAULT_UNITS)
  -w, --window SECONDS     Smoothing window in seconds (default: 30, or 90 for initial backups)
  -c, --no-colors          Disable colored output
  -s, --no-summary         Don't show summary on exit
  -d, --debug              Enable debug logging
  -l, --csv-log            Enable CSV logging
  -C, --create-config      Create sample config file and exit
  -v, --version            Show version and exit
  -h, --help               Show this help and exit

Configuration:
  Config file: ~/.config/tm-monitor/config.conf

  Settings can be configured via:
  1. Config file (if exists)
  2. Environment variables (TM_INTERVAL, TM_UNITS, etc.)
  3. Command line options (highest priority)

Examples:
  $(basename "$0")                    # Run with defaults
  $(basename "$0") -i 1 -d            # 1-second updates with debug
  $(basename "$0") --units 1024       # Use GiB instead of GB
  $(basename "$0") --csv-log          # Log data to CSV
  $(basename "$0") -w 120             # Use 2-minute smoothing window

Utilities:
  tm-monitor-resources     # Check CPU/memory usage of tm-monitor
  tm-monitor-resources -w  # Continuous resource monitoring

For more information:
  tm-monitor-resources --help

EOF
    exit 0
}

# Main monitoring loop - simplified to pure orchestration
monitor_loop() {
    local consecutive_failures=0
    local json_data
    local first_iteration=true

    while true; do
        # Get tmutil status (using centralized function)
        if json_data=$(get_tmutil_json); then
            consecutive_failures=0

            # Show metadata on first iteration
            if [[ "$first_iteration" == "true" ]]; then
                print_backup_metadata "$json_data"
                echo
                print_header
                first_iteration=false
            fi

            # Update state with new data
            update_state "$json_data"

            # Check if backup is running and display appropriate row
            if is_backup_running; then
                cache_dynamic_values
                print_data_row
            else
                print_idle_row
            fi
        else
            ((consecutive_failures++))
            debug "Failed to get tmutil status ($consecutive_failures/$MAX_FAILURES)"

            if (( consecutive_failures >= MAX_FAILURES )); then
                print_idle_row
                info "Time Machine is not running or unreachable"
                break
            fi
        fi

        sleep "$INTERVAL"
    done
}

# Setup helper process with initial backup detection
setup_helper() {
    if [[ ! -x "$HELPER_SCRIPT" ]]; then
        warn "Helper script not found at: $HELPER_SCRIPT"
        warn "Using inline processing (slower)"
        return 1
    fi

    if [[ -z "${TM_PYTHON_CMD:-}" ]]; then
        warn "Python 3 not found, using inline processing (slower)"
        return 1
    fi

    # Export required environment for helper
    export PYTHON_CMD="$TM_PYTHON_CMD"
    export TM_UNITS="$UNITS"
    
    # Check if this is an initial backup and set appropriate window
    local json_test
    if json_test=$(get_tmutil_json 2>/dev/null); then
        if echo "$json_test" | grep -q '"FirstBackup":"1"'; then
            debug "Initial backup detected, using 90 second smoothing window"
            export TM_SPEED_WINDOW="${TM_INITIAL_BACKUP_WINDOW:-90}"
            export TM_INITIAL_BACKUP_WINDOW="${TM_INITIAL_BACKUP_WINDOW:-90}"
        else
            export TM_SPEED_WINDOW="${TM_SPEED_WINDOW:-30}"
        fi
    else
        export TM_SPEED_WINDOW="${TM_SPEED_WINDOW:-30}"
    fi
    
    start_helper_process "$HELPER_SCRIPT"
    return 0
}

# Main entry point - significantly simplified
main() {
    # Parse arguments using centralized function
    if ! parse_tm_monitor_args "$@"; then
        usage
    fi

    # Initialize logging
    init_logging "${DEBUG:-false}" "${CSV_LOG:-false}"

    debug "Starting tm-monitor v$(get_version)"
    debug "Config: INTERVAL=$INTERVAL, UNITS=$UNITS, SHOW_COLORS=$SHOW_COLORS"

    # Check dependencies and single instance
    check_dependencies false  # false = not verbose
    check_single_instance

    # Initialize subsystems
    init_process_management
    init_session
    init_display

    # Start helper process if available
    setup_helper

    # Run monitoring loop
    monitor_loop

    # Cleanup will handle footer and summary via process.sh trap
}

# Run main function
main "$@"
